<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="/assets/css/pages.css"/>
  <title>gdoc audio</title>
  </head>
<body>

  <h1>Michael Caplan</h1>

  <nav class=internal>
    <a href="/projects.html" class=back_link>
    <img class=back_button src="assets/images/back_button.png"/>
    Projects
    </a>

    </nav>


  <h3 id="voice-over-google-docs">Voice over Google Docs</h3>

<p>This year I had the chance to participate in the annual <a href="https://2019.hackatbrown.org">hackathon</a> run at Brown University with my friend <a href="http://www.mcisler.com/">Mckenna Cisler</a>.</p>

<p>We are both members of the Brown Amateur Radio Club, so we were interested in doing something related to communication. We decided to build a VOIP client that piggybacked on Google Docs as a type of unconventional web socket. The github is <a href="https://github.com/MckennaCisler/audio-text-tx">here</a>, and usage is very simple if you want to try it out.</p>

<h3 id="the-build">The Build</h3>
<p>We started off by sketching out the data flow:</p>
<figure>
  <img src="/assets/gdocaudio/data.png" style="width: 75vw" />
  <figcaption><em>Data Flow </em></figcaption>
</figure>

<p>Then, working in python, we stitched together a working application.</p>

<p>First, we used the <a href="https://people.csail.mit.edu/hubert/pyaudio/">PyAudio</a> library to get data from the soundcard in the form of a byte array. Then, we use the base64 encoding to transform these bits into nice characters that can be represented in base ASCII. This gives us the text string that needs to be pushed to Google Docs.</p>

<p>All of the interaction with Google Docs was done through the <a href="https://selenium-python.readthedocs.io">Selenium Python</a> bindings. This let us copy and paste strings from Python very quickly. In order to get the base64 strings into the system clipboard, we used a library called <a href="https://pypi.org/project/pyperclip/">Pyperclip</a>. Using this library allowed us to then simply automate the “Ctrl”+”V” keypress action to move the string into a Google Doc.</p>

<p>On the receive end, a listener function constantly polled the Google Doc for new chunks of audio data. When it received some, it decoded the base64 and and then wrote those bytes to the soundcard.</p>

<p>We implemented some simple compression using the built-in python libraries, but didn’t notice any serious improvements.</p>

<h3 id="results">Results</h3>

<p>We were very happy with the results, and were able to send close to real-time audio over an unconventional medium.</p>

<p>Our main problem seemed to be due to the rate limits on Google Doc copy and paste operations. When we were transferring text too fast, the document skipped packets on the receive end. Going too fast meant that Google Docs couldn’t keep up. Ultimately, this meant that we had a close to 4 second lag on bidirectional communication, which made conversation very slow.</p>


  <nav class="external_nav">
  <a class=nav_link href="/about.html">About</a>
  <a class=nav_link href="/resume.html">Resume</a>
  <a class=nav_link href="https://discover-artsci.space/">Discover Project</a>
  <a class=nav_link href="http://www.github.com/mihcaelcaplan">Github</a>
  <a></a>
</nav>


  </body>
